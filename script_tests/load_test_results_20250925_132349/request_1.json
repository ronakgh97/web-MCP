{"responseId":1842537573,"message":"Search results found","userQuery":"RESTful API design","searchResultList":[{"success":true,"source":"https://restfulapi.net/rest-api-design-tutorial-with-example/","snippet":"How to Design a REST API - Step by Step Guide","content":"Learning REST in pieces is one thing while applying all these concepts to real application development is completely another challenge. This tutorial will teach us to design REST APIs for a network-based application. Please note that the takeaway from this whole exercise is learning how to apply REST principles in the application design process. 1. Identify the Resources – Object Modeling The first step in designing a REST API-based application is identifying the objects that will be presented as resources. For a network-based application, object modeling is pretty much more straightforward. There can be many things such as devices, managed entities, routers, modems, etc. For simplicity’s sake, we will consider only two resources i.e. Devices Configurations Here configuration may be a sub-resource of a device. A device can have many configuration options. Note that both objects/resources in our above model will have a unique identifier, which is the integer id property. 2. Create Model URIs Now when the object model is ready, it’s time to decide the resource URIs. At this step, while designing the resource URIs – focus on the relationship between resources and their sub-resources. These resource URIs are endpoints for APIs. In our application, a device is a top-level resource. And, configuration is a sub-resource under the device. Let’s write down the URIs. /devices /devices/{id} /configurations /configurations/{id} /devices/{id}/configurations /devices/{id}/configurations/{configId} Notice that these URIs do not use any verb or operation. It’s crucial not to include any verb in URIs. URIs should all be nouns only. 3. Determine Resource Representations Now that resource URIs have been decided, let’s work on their representations. Most representations are defined in either XML or JSON format. We will see XML examples as it is more expressive of how data is composed. 3.1. Collection Resource of Devices When returning a collection resource, include only the most important information about that resource. This will keep the size of the response payload small, and so will improve the performance of the API. <devices size=\"2\"> <link rel=\"self\" href=\"/devices\"/> <device id=\"12345\"> <link rel=\"self\" href=\"/devices/12345\"/> <deviceFamily>apple-es</deviceFamily> <OSVersion>10.3R2.11</OSVersion> <platform>SRX100B</platform> <serialNumber>32423457</serialNumber> <connectionStatus>up</connectionStatus> <ipAddr>192.168.21.9</ipAddr> <name>apple-srx_200</name> <status>active</status> </device> <device id=\"556677\"> <link rel=\"self\" href=\"/devices/556677\"/> <deviceFamily>apple-es</deviceFamily> <OSVersion>10.3R2.11</OSVersion> <platform>SRX100B</platform> <serialNumber>6453534</serialNumber> <connectionStatus>up</connectionStatus> <ipAddr>192.168.20.23</ipAddr> <name>apple-srx_200</name> <status>active</status> </device> </devices> 3.2. Single Device Resource Opposite to collection URI, a single resource URI includes complete information about a particular device. It also includes a list of links to sub-resources and other supported operations. This will make your REST API HATEOAS driven. <device id=\"12345\"> <link rel=\"self\" href=\"/devices/12345\"/> <id>12345</id> <deviceFamily>apple-es</deviceFamily> <OSVersion>10.0R2.10</OSVersion> <platform>SRX100-LM</platform> <serialNumber>32423457</serialNumber> <name>apple-srx_100_lehar</name> <hostName>apple-srx_100_lehar</hostName> <ipAddr>192.168.21.9</ipAddr> <status>active</status> <configurations size=\"2\"> <link rel=\"self\" href=\"/configurations\" /> <configuration id=\"42342\"> <link rel=\"self\" href=\"/configurations/42342\" /> </configuration> <configuration id=\"675675\"> <link rel=\"self\" href=\"/configurations/675675\" /> </configuration> </configurations> <method href=\"/devices/12345/exec-rpc\" rel=\"rpc\"/> <method href=\"/devices/12345/synch-config\"rel=\"synch device configuration\"/> </device> 3.3. Collection Resource of Configurations Similar to device collection representation, create configuration collection representation with only minimal information. <configurations size=\"20\"> <link rel=\"self\" href=\"/configurations\" /> <configuration id=\"42342\"> <link rel=\"self\" href=\"/configurations/42342\" /> </configuration> <configuration id=\"675675\"> <link rel=\"self\" href=\"/configurations/675675\" /> </configuration> … … </configurations> Please note that configurations collection representation inside device is similar to top-level configurations URI. The only difference is that configurations for a device are only two, so only two configuration items are listed as subresources under the device. 3.4. Single Configuration Resource Now, a single configuration resource representation must have all possible information about this resource – including relevant links. <configuration id=\"42342\"> <link rel=\"self\" href=\"/configurations/42342\" /> <content><![CDATA[…]]></content> <status>active</status> <link rel=\"very big raw configuration script\" href=\"/configurations/42342/raw\" /> </configuration> 3.5. Collection Resource of Configuration under a Single Device This sub-collection of configurations will be a subset of the primary collection of configurations and will be specific to a device only. As it is the subset of primary collection, DO NOT create a different representation data field than primary collection. Use the same presentation fields as the primary collection. <configurations size=\"2\"> <link rel=\"self\" href=\"/devices/12345/configurations\" /> <configuration id=\"53324\"> <link...","error":null},{"success":true,"source":"https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/","snippet":"Best practices for REST API design - Stack Overflow","content":"MARCH 2, 2020 Best practices for REST API design In this article, we'll look at how to design REST APIs to be easy to understand for anyone consuming them, future-proof, and secure and fast since they serve data to clients that may be confidential. REST APIs are one of the most common kinds of web interfaces available today. They allow various clients including browser apps to communicate with services via the REST API. Therefore, it's very important to design REST APIs properly so that we won't run into problems down the road. We have to take into account security, performance, and ease of use for API consumers. Otherwise, we create problems for clients that use our APIs, which isn’t pleasant and detracts people from using our API. If we don’t follow commonly accepted conventions, then we confuse the maintainers of the API and the clients that use them since it’s different from what everyone expects. In this article, we'll look at how to design REST APIs to be easy to understand for anyone consuming them, future-proof, and secure and fast since they serve data to clients that may be confidential. Accept and respond with JSON Use nouns instead of verbs in endpoint paths Name collections with plural nouns Nesting resources for hierarchical objects Handle errors gracefully and return standard error codes Allow filtering, sorting, and pagination Maintain Good Security Practices Cache data to improve performance Versioning our APIs What is a REST API? A REST API is an application programming interface architecture style that conforms to specific architectural constraints, like stateless communication and cacheable data. It is not a protocol or standard. While REST APIs can be accessed through a number of communication protocols, most commonly, they are called over HTTPS, so the guidelines below apply to REST API endpoints that will be called over the internet. Note: For REST APIs called over the internet, you'll like want to follow the best practices for REST API authentication. Accept and respond with JSON Even though some people think REST should only return hypertext (including Roy Fielding who created the term) REST APIs should accept JSON for request payload and also send responses to JSON. JSON is the standard for transferring data. Almost every networked technology can use it: JavaScript has built-in methods to encode and decode JSON either through the Fetch API or another HTTP client. Server-side technologies have libraries that can decode JSON without doing much work. There are other ways to transfer data. XML isn’t widely supported by frameworks without transforming the data ourselves to something that can be used, and that’s usually JSON. We can’t manipulate this data as easily on the client-side, especially in browsers. It ends up being a lot of extra work just to do normal data transfer. Form data is good for sending data, especially if we want to send files. But for text and numbers, we don’t need form data to transfer those since—with most frameworks—we can transfer JSON by just getting the data from it directly on the client side. It’s by far the most straightforward to do so. To make sure that when our REST API app responds with JSON that clients interpret it as such, we should set Content-Type in the response header to application/json after the request is made. Many server-side app frameworks set the response header automatically. Some HTTP clients look at the Content-Type response header and parse the data according to that format. The only exception is if we’re trying to send and receive files between client and server. Then we need to handle file responses and send form data from client to server. But that is a topic for another time. We should also make sure that our endpoints return JSON as a response. Many server-side frameworks have this as a built-in feature. Let’s take a look at an example API that accepts JSON payloads. This example will use the Express back end framework for Node.js. We can use the body-parser middleware to parse the JSON request body, and then we can call the res.json method with the object that we want to return as the JSON response as follows: const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/', (req, res) => {   res.json(req.body); }); app.listen(3000, () => console.log('server started')); bodyParser.json() parses the JSON request body string into a JavaScript object and then assigns it to the req.body object. Set the Content-Type header in the response to application/json; charset=utf-8 without any changes. The method above applies to most other back end frameworks. Use nouns instead of verbs in endpoint paths We shouldn't use verbs in our endpoint paths. Instead, we should use the nouns which represent the entity that the endpoint that we're retrieving or manipulating as the pathname. This is because our HTTP request method already has the verb. Having verbs in our API endpoint paths isn’t useful and it makes it unnecessarily long since it doesn’t convey any new information. The chosen verbs could vary by the developer’s whim. For instance, some like ‘get’ and some like ‘retrieve’, so it’s just better to let the HTTP GET verb tell us what and endpoint does. The action should be indicated by the HTTP request method that we're making. The most common methods include GET, POST, PUT, and DELETE. GET retrieves resources. POST submits new data to the server. PUT...","error":null}],"success":true,"executionTimeMs":18998,"resultCount":2}